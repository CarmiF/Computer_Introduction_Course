#include  "BSP.h"

             MODULE API
             PUBLIC State0,State1,State2,State3,ST1_ADC_Rdy
             EXTERN ClrLEDs,SetLEDs,EnterSleep,ST1_ADC_Conf,ADC_Req_Smple,Get_ADC10MEM,Stop_ADC, ConVdel, state
             
             EXTERN dot,Vavg, Volt, Navg ; string EXTERN
            
             EXTERN print_ch, lcd_clr, print_str, lcd_cmd ;LCD EXTERN
            
             RSEG   CODE


;-------------------------------------------------------------
;             State0
;-------------------------------------------------------------
State0                    
              ;call #ClrLEDs
              
              ;go to sleep
              call #EnterSleep
              ret

;-------------------------------------------------------------
;             State1
;-------------------------------------------------------------
State1        ; clear LEDs
              call #ClrLEDs
              
              ; ADC config
              CALL  #ST1_ADC_Conf
              
              ; ADC request
              CALL  #ADC_Req_Smple
              
              ; go to sleep
              call #EnterSleep
              
              ret

ST1_ADC_Rdy   ; calculation....
              
              ; get ADC10 value
              CALL  #Get_ADC10MEM
              pop   R5
              
              ; check in what section R5 is
              
              ; 0 , 128 , 256 , 384 , 512 , 640 , 768 , 896 , 1024
              
              
              ; ------------------------------
              ; check if above or below 512
              
              CMP   #512,R5
              JGE   Above512
              JMP   Below512
              
              ; ------------------------------
              
Above512      CMP   #768,R5
              JGE   A768B1024
              JMP   A512B768

Below512      CMP   #256,R5
              JGE   A256B512
              JMP   A0B256

              ; ---------------------------------

A768B1024     CMP   #896,R5
              JGE   ST1_LED7
              JMP   ST1_LED6



A512B768      CMP   #640,R5
              JGE   ST1_LED5
              JMP   ST1_LED4



A256B512      CMP   #384,R5
              JGE   ST1_LED3
              JMP   ST1_LED2


A0B256        CMP   #128,R5
              JGE   ST1_LED1
              JMP   ST1_LED0
              
              ; -----------------------------------


ST1_LED0     PUSH.B #0x01
             JMP    PutTOSIntoLED
ST1_LED1     PUSH.B #0x02
             JMP    PutTOSIntoLED             
ST1_LED2     PUSH.B #0x04
             JMP    PutTOSIntoLED
ST1_LED3     PUSH.B #0x08
             JMP    PutTOSIntoLED
ST1_LED4     PUSH.B #0x10
             JMP    PutTOSIntoLED
ST1_LED5     PUSH.B #0x20
             JMP    PutTOSIntoLED
ST1_LED6     PUSH.B #0x40
             JMP    PutTOSIntoLED
ST1_LED7     PUSH.B #0x80
             JMP    PutTOSIntoLED
             
PutTOSIntoLED CALL  #SetLEDs

              ; ------------------------------------

              ; ADC request
;ST1_NextSmple CALL  #ADC_Req_Smple
              
              ;go to sleep
              ; call #EnterSleep
              
              ret
;-------------------------------------------------------------
;             State2
;-------------------------------------------------------------
State2 
              NOP
              
              ret

;-------------------------------------------------------------
;             State3
;-------------------------------------------------------------
State3                    
              
              ; stop ADC
              ;CALL  #Stop_ADC
              
              ; clear LEDs
              ;call #ClrLEDs
              
              ;go to sleep
              PUSH.W  #Vavg
              CALL    #print_str
              
              PUSH.W  #765 ; value to print
              CALL    #Conv_ADCtoV
              MOV     #0,state
              
loop          jmp      loop
              call    #EnterSleep
              ret
                


            
;-------------------------------------------------------------
;             Convert ADC(0-1023) to V(0-3.55)
;-------------------------------------------------------------           

Conv_ADCtoV
              pop R7  ;Address to return
              POP R8
              RLA R8
              RLA R8
              RLA R8
              RLA R8
              ; now we need to multiply Navg with ConVdel
              PUSH R8
              PUSH ConVdel
              CALL #SPmult
              POP R4        ; R4 holds the lower word of result
              POP R5        ; R5 holds the higher word of result
              ; now we need to rotate both the higher and the lower word 4 times to the right
              RRA R5
              RRC R4
              RRA R5
              RRC R4
              RRA R5
              RRC R4
              RRA R5
              RRC R4
              ; now R5 holds the value of the digit that will be to the left of the dot
              
              ; ---- print the digit --------
              ADD     #48,R5
              PUSH.W  R5
              CALL    #print_ch
              
              ; ---- print the dot ----------
              PUSH.W  #46     
              CALL    #print_ch
              
              
              
              ; now we need to multiply the lower word register with 03E8h (1,000 in decimal)
              ; the higher word register will contain the 3 digits that we need to print after the dot
              PUSH R4
              PUSH #03E8h
              CALL #SPmult
              POP R4        ; R4 holds the lower word of result
              POP R5        ; R5 holds the higher word of result - the one that we need
              
              ; --------- print the number we got in R5 to the right of the dot -------
              
              push #0x14
              call #lcd_cmd
              push #0x14
              call #lcd_cmd
LOOPLOOP      push R5
              push #10
              CALL #DIV16
              POP R9              ; R9 == the remain --> the digit we want
              POP R5             ; the qoutient
                     
              ADD #48,R9
              push R9
              CALL #print_ch
              push #0x10
              call #lcd_cmd
              push #0x10
              call #lcd_cmd
              
              CMP #0,R5
              JNZ LOOPLOOP

              push R7      ;Address to return
              ret
  
;-------------------------------------------------------------
;             Multiplexer
;-------------------------------------------------------------
              
SPmult        POP R15   ; return address
              POP R14   ; R14 == FFFFh
              POP R13   ; R13 == Counter
              
              MOV #1,R10
              CLR R11
              CLR R12
L2            BIT R10,R14
              JZ L1
              ADD R13,R12
L1            RRC R12
              RRC R11
              RLA R10
              JNZ L2
              
              push.w R12		    ; push to stack the multiplication High word
	      push.w R11		    ; push to stack the multiplication Low word
	      push.w R15		    ; push back the caller return address
              ret



;-------------------------------------------------------------
;             Divider
;-------------------------------------------------------------
DIV16	  	pop.w R15			; R15 = the caller return address
		pop.w R14			; R14 = y = Divisor
		pop.w R13			; R13 = x = Dividend	                 
                mov     #17,R10			; R10=DIV16_STEP_COUNTER=16+1
                clr     R12                	; initialize the Quotient register
                clr     R11		   	; initialize the shift-register {|R11|R13|} Upper Word                 
DIVL3           rla     R12
DIVL1           dec     R10
                jz      DIVL2
                rla     R13
                rlc     R11
                cmp     R14,R11
                jlo     DIVL3
                sub     R14,R11
                setc
                rlc     R12
                jmp     DIVL1               
DIVL2           push.w   R12		   	; push the Quotient into stack
                push.w   R11		   	; push the Remainder into stack
		push.w   R15			; push back the caller return address
                ret	
            
            
            
            ENDMOD    
             END
